<script context="module">
	export const evidenceInclude = true;
</script>

<script>
	import { writable } from 'svelte/store';
	import { setContext } from 'svelte';
	import { propKey, configKey, strictBuild } from './context';
	let props = writable({});
	let config = writable({});

	$: setContext(propKey, props);
	$: setContext(configKey, config);

	import ECharts from './ECharts.svelte';
	import getColumnSummary from '@evidence-dev/component-utilities/getColumnSummary';
	import getDistinctValues from '@evidence-dev/component-utilities/getDistinctValues';
	import getStackPercentages from '@evidence-dev/component-utilities/getStackPercentages';
	import getSortedData from '@evidence-dev/component-utilities/getSortedData';
	import { standardizeDateColumn } from '@evidence-dev/component-utilities/dateParsing';
	import { formatAxisValue } from '@evidence-dev/component-utilities/formatting';
	import formatTitle from '@evidence-dev/component-utilities/formatTitle';
	import {
		formatValue,
		getFormatObjectFromString
	} from '@evidence-dev/component-utilities/formatting';
	import ErrorChart from './ErrorChart.svelte';
	import checkInputs from '@evidence-dev/component-utilities/checkInputs';
	import { colours } from '@evidence-dev/component-utilities/colours';

	// ---------------------------------------------------------------------------------------
	// Input Props
	// ---------------------------------------------------------------------------------------
	// Data and columns:
	export let data = undefined;
	export let x = undefined;
	export let y = undefined;
	export let series = undefined;
	export let size = undefined;
	export let tooltipTitle = undefined;

	// This should be reworked to fit better with svelte's reactivity.

	// We rewrite the x and y values with fallbacks if they aren't present
	// the fallback logic *depends* on the values of x and y
	// when x and y are replaced by the fallbacks, the fallback logic doesn't reset.
	// if the y value isn't set, var y gets populated with a fall back from the data.
	// if the data changes, we are now acting as if the fallback from above was entered by the user, and
	// then we throw if the fallback column is now missing.

	// This is a hack to get around the above
	const ySet = y ? true : false;
	const xSet = x ? true : false;

	export let swapXY = false; // Flipped axis chart
	$: if (swapXY === 'true' || swapXY === true) {
		swapXY = true;
	} else {
		swapXY = false;
	}

	// Chart titles:
	export let title = undefined;
	export let subtitle = undefined;

	// Chart type:
	export let chartType = 'Chart'; // Used to label chart error messages
	export let bubble = false;
	export let hist = false;
	let reqCols;

	// X axis:
	export let xType = undefined; // category or value
	export let xAxisTitle = 'false'; // Default false. If true, use formatTitle(x). Or you can supply a custom string
	export let xBaseline = true;
	xBaseline = xBaseline === 'true' || xBaseline === true;
	export let xTickMarks = false;
	xTickMarks = xTickMarks === 'true' || xTickMarks === true;
	export let xGridlines = false;
	xGridlines = xGridlines === 'true' || xGridlines === true;
	export let xAxisLabels = true;
	xAxisLabels = xAxisLabels === 'true' || xAxisLabels === true;
	export let sort = false; // sorts x values in case x is out of order in dataset (e.g., would create line chart that is out of order)
	sort = sort === 'true' || sort === true;
	export let xFmt = undefined;

	// Y axis:
	export let yAxisTitle = 'false'; // Default false. If true, use formatTitle(x). Or you can supply a custom string
	export let yBaseline = false;
	yBaseline = yBaseline === 'true' || yBaseline === true;
	export let yTickMarks = false;
	yTickMarks = yTickMarks === 'true' || yTickMarks === true;
	export let yGridlines = true;
	yGridlines = yGridlines === 'true' || yGridlines === true;
	export let yAxisLabels = true;
	yAxisLabels = yAxisLabels === 'true' || yAxisLabels === true;
	export let yMin = undefined;
	export let yMax = undefined;
	export let yFmt = undefined;

	// Other column formats:
	export let sizeFmt = undefined;

	// Legend:
	export let legend = undefined;

	// Additional Config Options:
	export let options = undefined; // additional ECharts config object that will append to the config generated by our API

	export let stacked100 = false;

	export let chartAreaHeight;
	chartAreaHeight = Number(chartAreaHeight);

	// What other chartAreaHeight values would be considered invalid?
	if (isNaN(chartAreaHeight) || chartAreaHeight < 0) {
		chartAreaHeight = 180;
	}

	// ---------------------------------------------------------------------------------------
	// Variable Declaration
	// ---------------------------------------------------------------------------------------
	// Column Summary:
	let columnSummary;
	let columnNames;
	let uColNames = [];
	let unusedColumns = [];
	let uColType;
	let uColName;
	let xDataType;
	let xMismatch;
	let xFormat;
	let yFormat;
	let sizeFormat;
	let xUnitSummary;
	let yUnitSummary;
	let xDistinct;

	// Individual Config Sections:
	let horizAxisConfig;
	let verticalAxisConfig;
	let horizAxisTitleConfig;
	let chartConfig;

	// Chart area sizing:
	let hasTitle;
	let hasSubtitle;
	let hasLegend;
	let hasTopAxisTitle;
	let hasBottomAxisTitle;
	let titleFontSize;
	let subtitleFontSize;
	let titleBoxPadding;
	let titleBoxHeight;
	let chartAreaPaddingTop;
	let chartAreaPaddingBottom;
	let bottomAxisTitleSize;
	let topAxisTitleSize;
	let legendHeight;
	let legendPaddingTop;
	let legendTop;
	let chartTop;
	let chartBottom;
	let chartContainerHeight;
	let topAxisTitleTop;

	let horizAxisTitle;

	// Adjustment to avoid small bars on horizontal bar chart (extend chart height to accomodate):
	let maxBars;
	let barCount;
	let heightMultiplier;

	// Set final chart height:
	let height;
	let width;

	let missingCols = [];

	let originalRun = true;

	// Error Handling:

	let inputCols = [];
	let optCols = [];
	let i;

	let error;

	// Date String Handling:
	let columnSummaryArray;
	let dateCols;

	$: {
		try {
			error = undefined;
			missingCols = [];
			unusedColumns = [];
			// Error Handling:
			inputCols = [];
			optCols = [];
			uColName = [];

			checkInputs(data); // check that dataset exists

			// ---------------------------------------------------------------------------------------
			// Get column information
			// ---------------------------------------------------------------------------------------
			// Get column summary:
			columnSummary = getColumnSummary(data);

			// Get column names:
			columnNames = Object.keys(columnSummary);

			// ---------------------------------------------------------------------------------------
			// Make assumptions to complete required props
			// ---------------------------------------------------------------------------------------
			// If no x column was supplied, assume first column in dataset is x
			if (!xSet) {
				x = columnNames[0];
			}

			// If no y column(s) supplied, assume all number columns other than x are the y columns:
			if (!ySet) {
				uColNames = columnNames.filter(function (col) {
					return ![x, series, size].includes(col);
				});

				for (let i = 0; i < uColNames.length; i++) {
					uColName = uColNames[i];
					uColType = columnSummary[uColName].type;
					if (uColType === 'number') {
						unusedColumns.push(uColName);
					}
				}

				y = unusedColumns.length > 1 ? unusedColumns : unusedColumns[0];
			}
			// Establish required columns based on chart type:
			if (bubble) {
				reqCols = {
					x: x,
					y: y,
					size: size
				};
			} else if (hist) {
				reqCols = {
					x: x
				};
			} else {
				reqCols = {
					x: x,
					y: y
				};
			}

			// Check which columns were not supplied to the chart:
			for (let property in reqCols) {
				if (reqCols[property] == null) {
					missingCols.push(property);
				}
			}

			if (missingCols.length === 1) {
				throw Error(new Intl.ListFormat().format(missingCols) + ' is required');
			} else if (missingCols.length > 1) {
				throw Error(new Intl.ListFormat().format(missingCols) + ' are required');
			}

			// Fix for stacked100 overwriting y variable. Bandaid fix - not a long-term solution:
			if (stacked100 === true && y.includes('_pct') && originalRun === false) {
				if (typeof y === 'object') {
					for (let i = 0; i < y.length; i++) {
						y[i] = y[i].replace('_pct', '');
					}
					originalRun = false;
				} else {
					y = y.replace('_pct', '');
					originalRun = false;
				}
			}

			// Check the inputs supplied to the chart:
			if (x) {
				inputCols.push(x);
			}
			if (y) {
				if (typeof y === 'object') {
					for (i = 0; i < y.length; i++) {
						inputCols.push(y[i]);
					}
				} else {
					inputCols.push(y);
				}
			}
			if (size) {
				inputCols.push(size);
			}
			if (series) {
				optCols.push(series);
			}
			if (tooltipTitle) {
				optCols.push(tooltipTitle);
			}

			checkInputs(data, inputCols, optCols);

			// ---------------------------------------------------------------------------------------
			// Aggregate Data if Required
			// ---------------------------------------------------------------------------------------

			if (stacked100 === true) {
				data = getStackPercentages(data, x, y);

				if (typeof y === 'object') {
					for (let i = 0; i < y.length; i++) {
						y[i] = y[i] + '_pct';
					}
					originalRun = false;
				} else {
					y = y + '_pct';
					originalRun = false;
				}

				// Re-run column summary for new columns (not ideal):
				columnSummary = getColumnSummary(data);
			}

			// ---------------------------------------------------------------------------------------
			// Define x axis type
			// ---------------------------------------------------------------------------------------
			xDataType = columnSummary[x].type;

			// Get xDataType into ECharts default types:
			switch (xDataType) {
				case 'number':
					xDataType = 'value';
					break;
				case 'string':
					xDataType = 'category';
					break;
				case 'date':
					xDataType = 'time';
					break;
				default:
					break;
			}

			xType = xType === 'category' ? 'category' : xDataType;

			// Throw error if attempting to plot value or time on horizontal x-axis:
			if (swapXY && xType !== 'category') {
				throw Error(
					'Horizontal charts do not support a value or time-based x-axis. You can either change your SQL query to output string values or set swapXY=false.'
				);
			}

			// Override xType if axes are swapped - only category enabled on horizontal axis
			if (swapXY) {
				xType = 'category';
			}

			// Check for x mismatch:
			xMismatch = xDataType === 'value' && xType === 'category';

			// ---------------------------------------------------------------------------------------
			// Sort data based on xType
			// ---------------------------------------------------------------------------------------
			data = sort
				? xDataType === 'category'
					? getSortedData(data, y, false)
					: getSortedData(data, x, true)
				: data;

			// Always sort time axes by x - this prevents the lines from being drawn out of order
			if (xDataType === 'time') {
				data = getSortedData(data, x, true);
			}

			// ---------------------------------------------------------------------------------------
			// Standardize date columns
			// ---------------------------------------------------------------------------------------

			columnSummaryArray = getColumnSummary(data, 'array');
			dateCols = columnSummaryArray.filter((d) => d.type === 'date');
			dateCols = dateCols.map((d) => d.id);

			if (dateCols.length > 0) {
				for (let i = 0; i < dateCols.length; i++) {
					data = standardizeDateColumn(data, dateCols[i]);
				}
			}

			// ---------------------------------------------------------------------------------------
			// Get format codes for axes
			// ---------------------------------------------------------------------------------------
			if (xFmt) {
				xFmt = getFormatObjectFromString(xFmt, columnSummary[x].format.valueType);
				// Override with provided format
				xFormat = xFmt;
			} else {
				xFormat = columnSummary[x].format;
			}

			if (!y) {
				yFormat = 'str';
			} else {
				if (yFmt) {
					if (typeof y === 'object') {
						yFmt = getFormatObjectFromString(yFmt, columnSummary[y[0]].format.valueType);
					} else {
						yFmt = getFormatObjectFromString(yFmt, columnSummary[y].format.valueType);
					}
					// Override with provided format
					yFormat = yFmt;
				} else {
					if (typeof y === 'object') {
						yFormat = columnSummary[y[0]].format;
					} else {
						yFormat = columnSummary[y].format;
					}
				}
			}

			if (size) {
				if (sizeFmt) {
					sizeFmt = getFormatObjectFromString(sizeFmt, columnSummary[size].format.valueType);
					// Override with provided format
					sizeFormat = sizeFmt;
				} else {
					sizeFormat = columnSummary[size].format;
				}
			}

			xUnitSummary = columnSummary[x].columnUnitSummary;

			if (y) {
				if (typeof y === 'object') {
					yUnitSummary = columnSummary[y[0]].columnUnitSummary;
				} else {
					yUnitSummary = columnSummary[y].columnUnitSummary;
				}
			}

			xAxisTitle =
				xAxisTitle === 'true' ? formatTitle(x, xFormat) : xAxisTitle === 'false' ? '' : xAxisTitle;
			yAxisTitle =
				yAxisTitle === 'true'
					? typeof y === 'object'
						? ''
						: formatTitle(y, yFormat)
					: yAxisTitle === 'false'
					? ''
					: yAxisTitle;

			// ---------------------------------------------------------------------------------------
			// Set legend flag
			// ---------------------------------------------------------------------------------------
			if (legend !== undefined) {
				legend = legend === 'true' || legend === true;
			}

			legend = legend ?? (series != undefined || typeof y === 'object');

			// ---------------------------------------------------------------------------------------
			// Add props to store to let child components access them
			// ---------------------------------------------------------------------------------------
			props.update((d) => {
				return {
					...d,
					data,
					x,
					y,
					series,
					swapXY,
					sort,
					xType,
					xFormat,
					yFormat,
					sizeFormat,
					xMismatch,
					size,
					yMin,
					columnSummary,
					xAxisTitle,
					yAxisTitle,
					tooltipTitle,
					chartAreaHeight,
					chartType
				};
			});

			// ---------------------------------------------------------------------------------------
			// Axis Configuration
			// ---------------------------------------------------------------------------------------
			xDistinct = getDistinctValues(data, x);

			if (swapXY) {
				horizAxisConfig = {
					type: 'value',
					position: 'top',
					axisLabel: {
						show: yAxisLabels,
						hideOverlap: true,
						showMaxLabel: true,
						formatter: function (value) {
							return formatAxisValue(value, yFormat, yUnitSummary);
						},
						margin: 4
					},
					min: yMin,
					max: yMax,
					splitLine: {
						show: yGridlines
					},
					axisLine: {
						show: yBaseline,
						onZero: false
					},
					axisTick: {
						show: yTickMarks
					},
					boundaryGap: false,
					z: 2
				};
			} else {
				horizAxisConfig = {
					type: xType,
					splitLine: {
						show: xGridlines
					},
					axisLine: {
						show: xBaseline
					},
					axisTick: {
						show: xTickMarks
					},
					axisLabel: {
						show: xAxisLabels,
						hideOverlap: true,
						showMaxLabel: xType === 'category' || xType === 'value', // max label for ECharts' time axis is a stub - default for that is false
						formatter:
							xType === 'time'
								? false
								: function (value) {
										return formatAxisValue(value, xFormat, xUnitSummary);
								  },
						margin: 6
					},
					scale: true,
					z: 2
				};
			}

			if (swapXY) {
				verticalAxisConfig = {
					type: xType,
					inverse: 'true',
					splitLine: {
						show: xGridlines
					},
					axisLine: {
						show: xBaseline
					},
					axisTick: {
						show: xTickMarks
					},
					axisLabel: {
						show: xAxisLabels,
						hideOverlap: true
						// formatter:
						//     function(value){
						//         return formatAxisValue(value, xFormat, xUnitSummary)
						//     },
					},
					scale: true,
					z: 2
				};
			} else {
				verticalAxisConfig = {
					type: 'value',
					splitLine: {
						show: yGridlines
					},
					axisLine: {
						show: yBaseline,
						onZero: false
					},
					axisTick: {
						show: yTickMarks
					},
					axisLabel: {
						show: yAxisLabels,
						hideOverlap: true,
						margin: 4,
						formatter: function (value) {
							return formatAxisValue(value, yFormat, yUnitSummary);
						}
					},
					name: yAxisTitle,
					nameLocation: 'end',
					nameTextStyle: {
						align: 'left',
						verticalAlign: 'top',
						backgroundColor: 'white',
						padding: [0, 5, 0, 0]
					},
					nameGap: 6,
					min: yMin,
					max: yMax,
					boundaryGap: ['0%', '1%'],
					z: 2
				};
			}

			// ---------------------------------------------------------------------------------------
			// Set up chart area
			// ---------------------------------------------------------------------------------------

			hasTitle = title ? true : false;
			hasSubtitle = subtitle ? true : false;
			hasLegend = legend * (series !== null || (typeof y === 'object' && y.length > 1));
			hasTopAxisTitle = yAxisTitle !== '' && swapXY;
			hasBottomAxisTitle = xAxisTitle !== '' && !swapXY;

			titleFontSize = 15;
			subtitleFontSize = 13;
			titleBoxPadding = 6 * hasSubtitle;

			titleBoxHeight =
				hasTitle * titleFontSize +
				hasSubtitle * subtitleFontSize +
				titleBoxPadding * Math.max(hasTitle, hasSubtitle);

			chartAreaPaddingTop = 10;
			chartAreaPaddingBottom = 8;

			bottomAxisTitleSize = 14;
			topAxisTitleSize = 14 + 0; // font size + padding top

			legendHeight = 15;
			legendHeight = legendHeight * hasLegend;

			legendPaddingTop = 7;
			legendPaddingTop = legendPaddingTop * Math.max(hasTitle, hasSubtitle);

			legendTop = titleBoxHeight + legendPaddingTop;
			chartTop =
				legendTop + legendHeight + topAxisTitleSize * hasTopAxisTitle + chartAreaPaddingTop;
			chartBottom = hasBottomAxisTitle * bottomAxisTitleSize + chartAreaPaddingBottom;
			chartContainerHeight = chartAreaHeight + chartTop + chartBottom;

			topAxisTitleTop = legendTop + legendHeight + 7;

			// Adjustment to avoid small bars on horizontal bar chart (extend chart height to accomodate)
			// Small bars are allowed on normal bar chart (e.g., time series bar chart)
			maxBars = 6;
			heightMultiplier = 1;
			if (swapXY) {
				barCount = xDistinct.length;
				heightMultiplier = Math.max(1, barCount / maxBars);
			}

			// Set final chart height:
			height = chartContainerHeight * heightMultiplier + 'px';
			width = '100%';

			// ---------------------------------------------------------------------------------------
			// Set up horizontal axis title (custom graphic)
			// ---------------------------------------------------------------------------------------
			horizAxisTitle = swapXY ? yAxisTitle : xAxisTitle;
			if (horizAxisTitle !== '') {
				horizAxisTitle = horizAxisTitle + ' â†’'; // u2192 is js escaped version of &rarr;
			}

			horizAxisTitleConfig = {
				id: 'horiz-axis-title',
				type: 'text',
				style: {
					text: horizAxisTitle,
					textAlign: 'right',
					fill: colours.grey500
				},
				cursor: 'auto',
				// Positioning (if swapXY, top right; otherwise bottom right)
				right: swapXY ? '2%' : '3%',
				top: swapXY ? topAxisTitleTop : null,
				bottom: swapXY ? null : '2%'
			};

			// ---------------------------------------------------------------------------------------
			// Build chart config and update config store so child components can access it
			// ---------------------------------------------------------------------------------------
			chartConfig = {
				title: {
					text: title,
					subtext: subtitle,
					subtextStyle: {
						width: width
					}
				},
				tooltip: {
					trigger: 'axis',
					// formatter function is overridden in ScatterPlot, BubbleChart, and Histogram
					formatter: function (params) {
						let output;
						let xVal;
						let yVal;
						let yCol;
						if (params.length > 1) {
							// If multi-series, add series name as title of tooltip
							xVal = params[0].value[swapXY ? 1 : 0];
							output = `<span id="tooltip" style='font-weight: 600;'>${formatValue(
								xVal,
								xFormat
							)}</span>`;
							for (let i = params.length - 1; i >= 0; i--) {
								yVal = params[i].value[swapXY ? 0 : 1];
								output =
									output +
									`<br> ${params[i].marker} ${
										params[i].seriesName
									} <span style='float:right; margin-left: 10px;'>${formatValue(
										yVal,
										yFormat
									)}</span>`;
							}
						} else if (xType === 'value') {
							// If single-series and a numerical x-axis, include x column as a normal column rather than title (so as not to show a number as the title)
							xVal = params[0].value[swapXY ? 1 : 0];
							yVal = params[0].value[swapXY ? 0 : 1];
							yCol = params[0].seriesName;
							output = `<span id="tooltip" style='font-weight: 600;'>${formatTitle(
								x,
								xFormat
							)}: </span><span style='float:right; margin-left: 10px;'>${formatValue(
								xVal,
								xFormat
							)}</span><br/><span style='font-weight: 600;'>${formatTitle(
								yCol,
								yFormat
							)}: </span><span style='float:right; margin-left: 10px;'>${formatValue(
								yVal,
								yFormat
							)}</span>`;
						} else {
							// If single series and categorical or date x-axis, use x value as title of tooltip
							xVal = params[0].value[swapXY ? 1 : 0];
							yVal = params[0].value[swapXY ? 0 : 1];
							yCol = params[0].seriesName;
							output = `<span id="tooltip" style='font-weight: 600;'>${formatValue(
								xVal,
								xFormat
							)}</span><br/><span>${formatTitle(
								yCol,
								yFormat
							)}: </span><span style='float:right; margin-left: 10px;'>${formatValue(
								yVal,
								yFormat
							)}</span>`;
						}
						return output;
					},
					confine: true,
					axisPointer: {
						// Use axis to trigger tooltip
						type: 'shadow' // 'shadow' as default; can also be 'line' or 'shadow'
					},
					padding: 6,
					borderRadius: 4,
					borderWidth: 1,
					borderColor: colours.grey400,
					backgroundColor: 'white',
					extraCssText:
						'box-shadow: 0 3px 6px rgba(0,0,0,.15); box-shadow: 0 2px 4px rgba(0,0,0,.12); z-index: 1;',
					textStyle: {
						color: colours.grey900,
						fontSize: 12,
						fontWeight: 400
					},
					order: 'valueDesc'
				},
				legend: {
					show: legend,
					type: 'scroll',
					top: legendTop,
					padding: [0, 0, 0, 0]
				},
				grid: {
					left: '0.5%',
					right: swapXY ? '4%' : '3%',
					bottom: chartBottom,
					top: chartTop,
					containLabel: true
				},
				xAxis: horizAxisConfig,
				yAxis: verticalAxisConfig,
				series: [],
				animation: true,
				graphic: horizAxisTitleConfig
			};

			if (options) {
				chartConfig = { ...chartConfig, ...options };
			}

			config.update(() => {
				return chartConfig;
			});
		} catch (e) {
			error = e.message;
			// if the build is in production fail instead of sending the error to the chart
			if (strictBuild) {
				throw error;
			}
			props.update((d) => {
				return { ...d, error };
			});
		}
	}

	$: data;
</script>

{#if !error}
	<slot />
	<ECharts config={$config} {height} {width} {data} />
{:else}
	<ErrorChart {error} {chartType} />
{/if}
